\chapter{外设部分}

\section{地址分配与总线}

表\ref{table:address_allocation}列举了数据和地址总线上各个设备的物理地址空间分配。为了使解码和请求的分发更方便，每一个设备都有 16MB 的地址空间，但其只会用到其中的一部分。下面各节将给出各个设备的详细行为描述。

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{名称} & \textbf{起始地址} & \textbf{结束地址} & \textbf{有效大小} & \textbf{类型} \\ \hline
    SRAM        & 0x00000000    & 0x007FFFFF    & 8 MB          & 存储          \\ \hline
    Flash       & 0x01000000    & 0x017FFFFF    & 8 MB          & 存储          \\ \hline
    Graphics    & 0x02000000    & 0x02075300    & 480004 B      & 混合          \\ \hline
    UART        & 0x03000000    & 0x03000000    & 2 地址          & 寄存器         \\ \hline
    Timer       & 0x04000000    & 0x04000000    & 2 地址          & 寄存器         \\ \hline
    Ethernet    & 0x05000000    & 0x05000000    & 2 地址          & 寄存器         \\ \hline
    GPIO        & 0x06000000    & 0x06000000    & 3 地址          & 寄存器         \\ \hline
    USB         & 0x07000000    & 0x07000000    & 2 地址          & 寄存器         \\ \hline
    Bootrom     & 0x1FC00000    & 0x1FC03FFF    & 16 KB         & 存储          \\ \hline
    \end{tabular}
    \caption{各外设的物理地址分配}
    \label{table:address_allocation}
\end{table}

CPU向总线传递的所有地址都必须按4对齐，也就是说最后两个二进制位必需是0，否则将会触发一个“地址错误”异常。如果尝试访问超出任何设备“有效大小”之外的地址，或者向声明为只读的地址写数据，后果将是不可预料的。

本项目计划采用哈佛架构，因此分指令与数据两条总线。其中指令总线主设备为CPU，从设备为Bootrom与SRAM；数据总线主设备为CPU，从设备为除Bootrom外所有外设。两条总线的工作机制都是一致的，即将CPU的读/写指令通过前缀匹配连接到相应设备控制器，并将其回复连接到CPU。由于此类简单总线不至引起冲突，总线地址分配也互不重合，因此不需要仲裁等进阶功能。

\section{存储设备}

SRAM、Flash和Bootrom都是存储设备，其中Bootrom是只读的，SRAM是易失的，Flash则是非易失的。出于性能考虑，SRAM和Bootrom都需要能保证在下一个时钟周期上升沿给出当前访存指令的请求结果，而Flash则需要较长的时间进行读写（尤其是写）。为了使CPU得到正确的结果，相关的设备控制模块需要拉高总线的\texttt{stall}信号指示CPU暂停流水线等待访存结束，直到在下一个上升沿能给出响应为止。而由于SRAM被同时挂接在两条总线上，它需要有能力在一个CPU周期内处理两次请求，或者在确实无法完成时正确地给出\texttt{stall}信号。

SRAM芯片的每个物理地址都存储一个字（32 bit），所以只需要将地址高30位直接传送给它。而Flash的每个物理地址存储的是半字（16 bit），所以在进行读时，控制器内部需要事实上进行两次连续的读操作后将结果拼接起来；在进行写时，Flash芯片只要求半字写，无需进行特殊处理。Bootrom由一个Xilinx IP核生成，每个地址对应一个字。

在物理接口上，Flash芯片、SRAM芯片与Bootrom所使用的Xilinx IP核都遵循了所谓的“SRAM接口”，即有片选（CE）、读使能（OE）、写使能（WE）、地址（Address）和数据（Data）信号，其中除数据线为双向（IP核拆分为出入两条），其余均为FPGA需要给出的。三者对读写过程都分别有不同的时序要求，需要根据各自的数据手册正确实现读写时序。此外，Flash芯片还有一些额外的信号，如写保护、重置等，也需要正确处理。

\section{UART串口}

UART是一种无状态协议，实验板上为其预留了TX与RX两条信号线。本项目将使用开源的串口组件作为底层的收发器，串口控制器共向外暴露两个寄存器地址。第一个寄存器（\texttt{0x03000000}）是只读的，最低位指示 CTS (Clear To Send) 信号，表示可以发送数据；次低位是 DR (Data Ready) 信号，表示有未读取的数据。第二个寄存器（\texttt{0x03000004}）是可读写的，当 CTS 信号为高，写操作能向TX信号线上发送一个Byte（高位被忽略）；当DR信号为高，读操作能够获得一个RX信号线上传来的Byte。

UART控制器模块使用115200的标准波特率，1个停止位，无校验位。读、写两端都应当有足够大的FIFO缓冲区（如4K）来保证读/写不会因为发送过快或一段时间没有取走而产生非预期结果。只要有数据没有被取走，控制器就应当保持拉高一个外部设备中断。

\section{显示控制器}

表中控制器的类型是“混合”，是由于它由 240000 字节的图形缓冲区（framebuffer）和一个处于末尾的（0x2075300）配置寄存器组成。在图形缓冲区中，能存储800*600像素的图像，每个像素占据8比特，格式为\texttt{\{RED[2:0], GREEN[2:0], BLUE[1:0]\}}。控制寄存器是可读写的，用来指示图形缓冲区中第一个像素的偏移量，这可以帮助操作系统渲染终端等画面时方便地实现滚动功能。

本项目将把缓冲区中的内容，以 \texttt{800*600@75Hz} 的画面格式，借助TFP 410芯片产生DVI信号，通过HDMI接口输出。为此，需要借助像素时钟（50MHz），正确地产生符合VGA标准的行、场同步信号，从缓冲区读取并输出相应颜色数据。除此之外，还要正确借助控制寄存器来实现含偏移的渲染。

\section{GPIO控制器}

GPIO控制器包含三个寄存器地址，第一个（\texttt{0x06000000}）是只读的拨码开关状态， 第二个（\texttt{0x06000004}）和第三个（\texttt{0x06000008}）是可读写的，分别代表七段数码管和LED的显示。对应实验板上这三种设备的数量，这些寄存器都只有低16位是有意义的。特别地，当\texttt{0x060004}地址的最高为被置于0时，七段数码管的译码功能被启用，只有最低八位是有效且会被显示的；如果被置于1，则译码停用，七段数码管共有16个笔画（包括两个小数点），恰好能够显示一个16位整数。

\section{定时器}

定时器模块的第一个寄存器（\texttt{0x04000000}）包含了一个每1微妙自动递增的整数，并可以被修改为任意值。它可以被用来不受实际CPU频率影响地计量一些指令执行的时间。第二个寄存器（\texttt{0x04000004}）包含了CPU主时钟的周期计数。这两个寄存器都会在硬重置时被归零。

\section{以太网与USB控制器}

作为额外的需求，以太网与USB控制器的硬件逻辑实现并不复杂。它们的硬件同样基于SRAM接口，因此读写可以复用部分Flash与SRAM控制器的代码。但需要注意的是二者对时序也另有各自的要求，以太网控制器一般可以在30ns内完成一个请求，而USB控制器则需要较长的等待。二者暴露的第一个寄存器都是可写的地址选择寄存器（SL811使用了最低8位，而DM9000A甚至只是用了最低位），第二个寄存器是可读写的数据寄存器（SL811最低8位有效，DM9000A最低16位有效）。需要特别注意的书，对于同一个地址的多次，DM9000A可能给出不同的结果，这也反映在对其数据寄存器的读取结果上。

这两个部件的操作和通信都较复杂，都需要操作系统中驱动程序的配合才能进行工作。USB控制器与以太网控制器都有硬件的中断信号输入，项目中需要将它们同步后直接连接到CPU的硬件中断端口，以使得操作系统正常处理来自外部硬件的数据和请求。